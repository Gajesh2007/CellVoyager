DOCUMENTATION ANALYSIS FOR: covid19_test3_analysis_1.ipynb
================================================================================

Total cells: 21
Code cells: 7
Code cells with content: 7

CODE CELL 1 (Cell Index 1)
Documentation Length: 1281 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import warnings

# Set up visualization defaults for better plots
sc.settings.verbosity = 3  # verbosity: errors (0), warnings (1), info (2), hints (3)
sc.settings.figsize = (8, 8)
sc.settings.dpi = 100
sc.settings.facecolor = 'white'
warnings.filterwarnings('ignore')

# Set Matplotlib and Seaborn styles for better visualization
plt.rcParams['figure.figsize'] = (10, 8)
plt.rcParams['savefig.dpi'] = 150
sns.set_style('whitegrid')
sns.set_context('notebook', font_scale=1.2)

# Load data
print("Loading data...")
adata = sc.read_h5ad("example/covid19.h5ad")
print(f"Data loaded: {adata.shape[0]} cells and {adata.shape[1]} genes")
```

DOCUMENTATION:
sc.read_h5ad:
Read `.h5ad`-formatted hdf5 file.

Parameters
----------
filename
    File name of data file.
backed
    If `'r'`, load :class:`~anndata.AnnData` in `backed` mode
    instead of fully loading it into memory (`memory` mode).
    If you want to modify backed attributes of the AnnData object,
    you need to choose `'r+'`.

    Currently, `backed` only support updates to `X`. That means any
    changes to other slots like `obs` will not be written to disk in
    `backed` mode. If you would like save changes made to these slots
    of a `backed` :class:`~anndata.AnnData`, write them to a new file
    (see :meth:`~anndata.AnnData.write`). For an example, see
    [here] (https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html#Partial-reading-of-large-data).
as_sparse
    If an array was saved as dense, passing its name here will read it as
    a sparse_matrix, by chunk of size `chunk_size`.
as_sparse_fmt
    Sparse format class to read elements from `as_sparse` in as.
chunk_size
    Used only when loading sparse dataset that is stored as dense.
    Loading iterates through chunks of the dataset of this row size
    until it reads the whole dataset.
    Higher size means higher memory consumption and higher (to a point)
    loading speed.

================================================================================

CODE CELL 2 (Cell Index 4)
Documentation Length: 4249 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import scanpy as sc
import matplotlib.pyplot as plt

# Subset the T cells (assuming T cells are annotated as 'CD4 T' or 'CD8 T' in cell_type_coarse)
tcell_mask = adata.obs['cell_type_coarse'].isin(['CD4 T', 'CD8 T'])
adata_t = adata[tcell_mask].copy()

# Define standard S-phase and G2M-phase gene lists
# Note: Some genes (e.g. 'TYMS' and 'RRM2') appear in both lists; this is intentional to capture their roles in both phases.
s_genes = [
    'MCM5', 'PCNA', 'TYMS', 'FEN1', 'MCM2', 'MCM4', 'RRM1', 'UNG', 'GINS2',
    'MCM6', 'CDCA7', 'DTL', 'PRIM1', 'UHRF1', 'HELLS', 'RFC2', 'RPA2', 'NASP',
    'RAD51AP1', 'GMNN', 'WDR76', 'SLBP', 'CCNE2', 'UBR7', 'POLD3', 'MSH2',
    'ATAD2', 'RAD51', 'RRM2', 'CDC45', 'CDC6', 'EXO1'
]

g2m_genes = [
    'HMGB2', 'CDK1', 'NUSAP1', 'UBE2C', 'TOP2A', 'CDC20', 'TYMS', 'HMMR',
    'TPX2', 'CKS2', 'RRM2', 'ANP32E', 'NCAPD2', 'DLGAP5', 'CDCA3', 'NDC80',
    'NCAPG2', 'MKI67', 'TMPO', 'CENPF', 'G2E3', 'CENPA'
]

# Compute cell cycle scores for the T cell subset
sc.tl.score_genes_cell_cycle(adata_t, s_genes=s_genes, g2m_genes=g2m_genes)

# Visualize the cell cycle scores stratified by disease status (COVID vs Healthy)
sc.pl.violin(adata_t, keys=['S_score', 'G2M_score'], groupby='Status', jitter=0.4, rotation=45, stripplot=True)
plt.show()
```

DOCUMENTATION:
sc.pl.violin:
Violin plot.

Wraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.

Parameters
----------
adata
    Annotated data matrix.
keys
    Keys for accessing variables of `.var_names` or fields of `.obs`.
groupby
    The key of the observation grouping to consider.
log
    Plot on logarithmic axis.
use_raw
    Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.
stripplot
    Add a stripplot on top of the violin plot.
    See :func:`~seaborn.stripplot`.
jitter
    Add jitter to the stripplot (only when stripplot is True)
    See :func:`~seaborn.stripplot`.
size
    Size of the jitter points.
layer
    Name of the AnnData object layer that wants to be plotted. By
    default adata.raw.X is plotted. If `use_raw=False` is set,
    then `adata.X` is plotted. If `layer` is set to a valid layer name,
    then the layer is plotted. `layer` takes precedence over `use_raw`.
scale
    The method used to scale the width of each violin.
    If 'width' (the default), each violin will have the same width.
    If 'area', each violin will have the same area.
    If 'count', a violin’s width corresponds to the number of observations.
order
    Order in which to show the categories.
multi_panel
    Display keys in multiple panels also when `groupby is not None`.
xlabel
    Label of the x axis. Defaults to `groupby` if `rotation` is `None`,
    otherwise, no label is shown.
ylabel
    Label of the y axis. If `None` and `groupby` is `None`, defaults
    to `'value'`. If `None` and `groubpy` is not `None`, defaults to `keys`.
rotation
    Rotation of xtick labels.
show
     Show the plot, do not return axis.
save
    If `True` or a `str`, save the figure.
    A string is appended to the default filename.
    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.
ax
    A matplotlib axes object. Only works if plotting a single component.
**kwds
    Are passed to :func:`~seaborn.violinplot`.

Returns
-------
A :class:`~matplotlib.axes.Axes` object if `ax` is `None` else `None`.

Examples
--------

.. plot::
    :context: close-figs

    import scanpy as sc
    adata = sc.datasets.pbmc68k_reduced()
    sc.pl.violin(adata, keys='S_score')

Plot by category. Rotate x-axis labels so that they do not overlap.

.. plot::
    :context: close-figs

    sc.pl.violin(adata, keys='S_score', groupby='bulk_labels', rotation=90)

Set order of categories to be plotted or select specific categories to be plotted.

.. plot::
    :context: close-figs

    groupby_order = ['CD34+', 'CD19+ B']
    sc.pl.violin(adata, keys='S_score', groupby='bulk_labels', rotation=90,
        order=groupby_order)

Plot multiple keys.

.. plot::
    :context: close-figs

    sc.pl.violin(adata, keys=['S_score', 'G2M_score'], groupby='bulk_labels',
        rotation=90)

For large datasets consider omitting the overlaid scatter plot.

.. plot::
    :context: close-figs

    sc.pl.violin(adata, keys='S_score', stripplot=False)

.. currentmodule:: scanpy

See also
--------
pl.stacked_violin

sc.tl.score_genes_cell_cycle:
Score cell cycle genes :cite:p:`Satija2015`.

Given two lists of genes associated to S phase and G2M phase, calculates
scores and assigns a cell cycle phase (G1, S or G2M). See
:func:`~scanpy.tl.score_genes` for more explanation.

Parameters
----------
adata
    The annotated data matrix.
s_genes
    List of genes associated with S phase.
g2m_genes
    List of genes associated with G2M phase.
copy
    Copy `adata` or modify it inplace.
**kwargs
    Are passed to :func:`~scanpy.tl.score_genes`. `ctrl_size` is not
    possible, as it's set as `min(len(s_genes), len(g2m_genes))`.

Returns
-------
Returns `None` if `copy=False`, else returns an `AnnData` object. Sets the following fields:

`adata.obs['S_score']` : :class:`pandas.Series` (dtype `object`)
    The score for S phase for each cell.
`adata.obs['G2M_score']` : :class:`pandas.Series` (dtype `object`)
    The score for G2M phase for each cell.
`adata.obs['phase']` : :class:`pandas.Series` (dtype `object`)
    The cell cycle phase (`S`, `G2M` or `G1`) for each cell.

See also
--------
score_genes

Examples
--------
See this `notebook <https://github.com/scverse/scanpy_usage/tree/master/180209_cell_cycle>`__.

================================================================================

CODE CELL 3 (Cell Index 7)
Documentation Length: 0 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import pearsonr
import pandas as pd

# Extract the relevant columns from the T cell subset and drop missing values
df = adata_t.obs[['S_score', 'G2M_score', 'Status', 'IFN1']].copy()
df.dropna(subset=['S_score', 'G2M_score', 'IFN1'], inplace=True)

# Dictionary to store correlation results; define minimum data points required for Pearson correlation
corr_results = {}
min_points = 3

# Loop through each disease status, compute Pearson correlations with error handling
for status in df['Status'].unique():
    subset = df[df['Status'] == status]
    if len(subset) < min_points:
        print(f"Not enough data for status {status} to compute correlation.")
        continue
    try:
        s_corr, s_p = pearsonr(subset['S_score'], subset['IFN1'])
        g2m_corr, g2m_p = pearsonr(subset['G2M_score'], subset['IFN1'])
    except Exception as e:
        print(f"Error computing correlation for status {status}: {e}")
        continue
    corr_results[status] = {
        'S_score': {'correlation': s_corr, 'p_value': s_p},
        'G2M_score': {'correlation': g2m_corr, 'p_value': g2m_p}
    }
    print(f"Status: {status}")
    print(f" - S_score vs IFN1: Pearson r = {s_corr:.3f}, p = {s_p:.3e}")
    print(f" - G2M_score vs IFN1: Pearson r = {g2m_corr:.3f}, p = {g2m_p:.3e}")

# Create a grid layout with two subplots for side-by-side comparison of S_score and G2M_score correlations
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Plot for S_score vs IFN1
sns.regplot(data=df, x='S_score', y='IFN1', ax=axes[0], scatter_kws={'s':50}, line_kws={'color':'red'})
axes[0].set_title('S_score vs IFN1')
axes[0].set_xlabel('S Phase Score')
axes[0].set_ylabel('IFN1 Expression')

# Annotate S_score plot with correlation statistics for each disease status
for status in df['Status'].unique():
    subset = df[df['Status'] == status]
    if len(subset) >= min_points and status in corr_results:
        s_corr = corr_results[status]['S_score']['correlation']
        s_p = corr_results[status]['S_score']['p_value']
        # Position annotations slightly differently based on status to avoid overlap
        y_pos = 0.9 if status == 'COVID' else 0.8
        axes[0].annotate(f"{status}: r={s_corr:.2f}, p={s_p:.2e}",
                         xy=(0.05, y_pos), xycoords='axes fraction', fontsize=10, color='black')

# Plot for G2M_score vs IFN1
sns.regplot(data=df, x='G2M_score', y='IFN1', ax=axes[1], scatter_kws={'s':50}, line_kws={'color':'red'})
axes[1].set_title('G2M_score vs IFN1')
axes[1].set_xlabel('G2M Phase Score')
axes[1].set_ylabel('IFN1 Expression')

# Annotate G2M_score plot with correlation statistics
for status in df['Status'].unique():
    subset = df[df['Status'] == status]
    if len(subset) >= min_points and status in corr_results:
        g2m_corr = corr_results[status]['G2M_score']['correlation']
        g2m_p = corr_results[status]['G2M_score']['p_value']
        y_pos = 0.9 if status == 'COVID' else 0.8
        axes[1].annotate(f"{status}: r={g2m_corr:.2f}, p={g2m_p:.2e}",
                         xy=(0.05, y_pos), xycoords='axes fraction', fontsize=10, color='black')

plt.tight_layout()
plt.show()
```

DOCUMENTATION:
(No scanpy/scvi function calls found)

================================================================================

CODE CELL 4 (Cell Index 10)
Documentation Length: 0 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import numpy as np
import pandas as pd
import scanpy as sc
import matplotlib.pyplot as plt
import seaborn as sns

# Define candidate genes for ligands and receptors
ligand_genes = ['TNF', 'IL1B', 'IL6']
receptor_genes = ['TNFRSF1A', 'IL1R1', 'IL6R']

# Subset the data for monocytes and T cells
# For monocytes, we focus on 'CD14 Monocyte'
monocyte_mask = adata.obs['cell_type_coarse'] == 'CD14 Monocyte'
adata_mon = adata[monocyte_mask].copy()

# For T cells, include both 'CD4 T' and 'CD8 T'
tcell_mask = adata.obs['cell_type_coarse'].isin(['CD4 T', 'CD8 T'])
adata_t = adata[tcell_mask].copy()

# Function to compute average gene expression per donor for a given set of genes
# Grouping is done on both 'Donor_full' and 'Status' to capture donor variability within each condition

def compute_avg_expression(adata_subset, gene_list):
    # Create a dataframe with donor and status information
    meta = adata_subset.obs[['Donor_full', 'Status']].copy()
    avg_expr = meta.copy()
    
    for gene in gene_list:
        if gene not in adata_subset.var_names:
            print(f"Gene {gene} not found in the dataset.")
            avg_expr[gene] = np.nan
            continue
        # Extract expression for the gene
        expr = adata_subset[:, gene].X
        # Convert to dense array if necessary
        if hasattr(expr, 'toarray'):
            expr = expr.toarray().flatten()
        else:
            expr = np.array(expr).flatten()
        avg_expr[gene] = expr
    
    # Group by both Donor_full and Status to compute the average expression per donor
    group_avg = avg_expr.groupby(['Donor_full', 'Status']).mean().reset_index()
    return group_avg

# Compute average ligand expression in monocytes
df_mon = compute_avg_expression(adata_mon, ligand_genes)
print("Monocyte ligand expression per donor:")
print(df_mon.head())

# Compute average receptor expression in T cells
df_t = compute_avg_expression(adata_t, receptor_genes)
print("\nT cell receptor expression per donor:")
print(df_t.head())

# These dataframes (df_mon and df_t) now store the average expression of candidate genes for each donor
# stratified by disease Status (COVID or Healthy). They will serve as the basis for subsequent statistical testing
# and visualization of intercellular communication differences.

# Display simple boxplots for one candidate gene from each group as a sanity check
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
sns.boxplot(x='Status', y='TNF', data=df_mon, palette='Set2')
plt.title('Average TNF Expression in Monocytes')

plt.subplot(1, 2, 2)
sns.boxplot(x='Status', y='TNFRSF1A', data=df_t, palette='Set2')
plt.title('Average TNFRSF1A Expression in T cells')

plt.tight_layout()
plt.show()
```

DOCUMENTATION:
(No scanpy/scvi function calls found)

================================================================================

CODE CELL 5 (Cell Index 13)
Documentation Length: 0 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import mannwhitneyu

# Defining candidate genes for ligands (monocytes) and receptors (T cells)
ligand_genes = ['TNF', 'IL1B', 'IL6']
receptor_genes = ['TNFRSF1A', 'IL1R1', 'IL6R']

# Function to perform Mann–Whitney U test for a given gene in a dataframe
# The two-sided alternative is chosen because we do not assume that expression in one condition is strictly higher or lower than the other.
def differential_test(df, gene):
    # Filter data into COVID and Healthy groups and drop missing values
    group_covid = df[df['Status'] == 'COVID'][gene].dropna()
    group_healthy = df[df['Status'] == 'Healthy'][gene].dropna()
    # Ensure minimal sample size (at least 3 data points per group) to run the test
    if len(group_covid) < 3 or len(group_healthy) < 3:
        return None, None
    # Perform the two-sided Mann–Whitney U test
    stat, p_value = mannwhitneyu(group_covid, group_healthy, alternative='two-sided')
    return stat, p_value

# Dictionaries to store test results for monocytes and T cells
results_mon = {}
results_t = {}

# Differential expression analysis for candidate ligand genes in monocytes dataframe (df_mon)
for gene in ligand_genes:
    stat, p_val = differential_test(df_mon, gene)
    if p_val is not None:
        results_mon[gene] = {'MannWhitney_stat': stat, 'p_value': p_val}
        print(f"Monocytes - {gene}: Mann-Whitney U statistic = {stat:.2f}, p-value = {p_val:.3e}")
    else:
        print(f"Monocytes - {gene}: Not enough data for statistical testing.")

# Differential expression analysis for T cell receptor genes in dataframe (df_t)
for gene in receptor_genes:
    stat, p_val = differential_test(df_t, gene)
    if p_val is not None:
        results_t[gene] = {'MannWhitney_stat': stat, 'p_value': p_val}
        print(f"T cells - {gene}: Mann-Whitney U statistic = {stat:.2f}, p-value = {p_val:.3e}")
    else:
        print(f"T cells - {gene}: Not enough data for statistical testing.")

# Visualization for monocyte ligand genes using annotated boxplots
plt.figure(figsize=(14, 6))
for i, gene in enumerate(ligand_genes, 1):
    plt.subplot(1, 3, i)
    # Boxplot comparing average expression in COVID vs Healthy for each gene
    sns.boxplot(x='Status', y=gene, data=df_mon, palette='Set2')
    plt.title(f'Monocyte {gene} Expression')
    # Annotate the subplot with p-value if test results exist
    if gene in results_mon:
        p_val = results_mon[gene]['p_value']
        plt.annotate(f'p = {p_val:.2e}', xy=(0.5, 0.9), xycoords='axes fraction', ha='center', fontsize=10, color='red')
plt.tight_layout()
plt.show()

# Visualization for T cell receptor genes using annotated boxplots
plt.figure(figsize=(14, 6))
for i, gene in enumerate(receptor_genes, 1):
    plt.subplot(1, 3, i)
    sns.boxplot(x='Status', y=gene, data=df_t, palette='Set2')
    plt.title(f'T cell {gene} Expression')
    if gene in results_t:
        p_val = results_t[gene]['p_value']
        plt.annotate(f'p = {p_val:.2e}', xy=(0.5, 0.9), xycoords='axes fraction', ha='center', fontsize=10, color='red')
plt.tight_layout()
plt.show()
```

DOCUMENTATION:
(No scanpy/scvi function calls found)

================================================================================

CODE CELL 6 (Cell Index 16)
Documentation Length: 8705 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import scanpy as sc
import numpy as np
import matplotlib.pyplot as plt

# Subset T cells from the main anndata object (assuming T cells are labeled as 'CD4 T' or 'CD8 T')
tcell_mask = adata.obs['cell_type_coarse'].isin(['CD4 T', 'CD8 T'])
adata_t = adata[tcell_mask].copy()

# Check that TNFRSF1A is present in the dataset
if 'TNFRSF1A' not in adata_t.var_names:
    raise ValueError('TNFRSF1A gene not found in the T cell subset.')

# Extract TNFRSF1A expression values and compute the median
expression = adata_t[:, 'TNFRSF1A'].X
if hasattr(expression, 'toarray'):
    expression = expression.toarray().flatten()
else:
    expression = np.array(expression).flatten()

tnfrsf1a_median = np.median(expression)

# Create a new observation column to classify cells as High or Low expression
adata_t.obs['TNFRSF1A_grp'] = ['High' if x > tnfrsf1a_median else 'Low' for x in expression]

# Validate group balance by counting cells in each group
group_counts = adata_t.obs['TNFRSF1A_grp'].value_counts()
print('Cell counts for TNFRSF1A groups:')
print(group_counts)

# Visualize group sizes with a bar plot
plt.figure(figsize=(6,4))
group_counts.plot(kind='bar', color=['skyblue', 'orange'])
plt.ylabel('Cell Count')
plt.title('T cell counts by TNFRSF1A expression group (High vs Low)')
plt.show()

# Warn if any group has fewer than a minimal threshold of cells (e.g., 50 cells)
min_cells = 50
if group_counts.min() < min_cells:
    print(f'Warning: One of the groups has fewer than {min_cells} cells. Differential expression analysis may be less robust.')

# Perform differential expression analysis between High and Low groups using Wilcoxon test
sc.tl.rank_genes_groups(adata_t, groupby='TNFRSF1A_grp', method='wilcoxon', key_added='rank_genes_TNFRSF1A')

# Visualize the top 10 genes differentially expressed in each group using a dotplot
sc.pl.rank_genes_groups_dotplot(adata_t, key='rank_genes_TNFRSF1A', n_genes=10, swap_axes=True, show=True)
```

DOCUMENTATION:
sc.pl.rank_genes_groups_dotplot:
Plot ranking of genes using dotplot plot (see :func:`~scanpy.pl.dotplot`)

Parameters
----------
adata
    Annotated data matrix.
groups
    The groups for which to show the gene ranking.
n_genes
    Number of genes to show. This can be a negative number to show for
    example the down regulated genes. eg: num_genes=-10. Is ignored if
    `gene_names` is passed.
gene_symbols
    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`
    refer to the index column of the `.var` DataFrame. Setting this option allows
    alternative names to be used.
groupby
    The key of the observation grouping to consider. By default,
    the groupby is chosen from the rank genes groups parameter but
    other groupby options can be used.  It is expected that
    groupby is a categorical. If groupby is not a categorical observation,
    it would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).
min_logfoldchange
    Value to filter genes in groups if their logfoldchange is less than the
    min_logfoldchange
key
    Key used to store the ranking results in `adata.uns`.
values_to_plot
    Instead of the mean gene value, plot the values computed by `sc.rank_genes_groups`.
    The options are: ['scores', 'logfoldchanges', 'pvals', 'pvals_adj',
    'log10_pvals', 'log10_pvals_adj']. When plotting logfoldchanges a divergent
    colormap is recommended. See examples below.
var_names
    Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)
    to check their fold changes or p-values, instead of the top/bottom genes. The
    var_names could be a dictionary or a list as in :func:`~scanpy.pl.dotplot` or
    :func:`~scanpy.pl.matrixplot`. See examples below.
show
     Show the plot, do not return axis.
save
    If `True` or a `str`, save the figure.
    A string is appended to the default filename.
    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.
ax
    A matplotlib axes object. Only works if plotting a single component.
return_fig
    Returns :class:`DotPlot` object. Useful for fine-tuning
    the plot. Takes precedence over `show=False`.
**kwds
    Are passed to :func:`~scanpy.pl.dotplot`.

Returns
-------
If `return_fig` is `True`, returns a :class:`DotPlot` object,
else if `show` is false, return axes dict

Examples
--------

.. plot::
    :context: close-figs

    import scanpy as sc
    adata = sc.datasets.pbmc68k_reduced()
    sc.tl.rank_genes_groups(adata, 'bulk_labels', n_genes=adata.raw.shape[1])

Plot top 2 genes per group.

.. plot::
    :context: close-figs

    sc.pl.rank_genes_groups_dotplot(adata,n_genes=2)

Plot with scaled expressions for easier identification of differences.

.. plot::
    :context: close-figs

    sc.pl.rank_genes_groups_dotplot(adata, n_genes=2, standard_scale='var')

Plot `logfoldchanges` instead of gene expression. In this case a diverging colormap
like `bwr` or `seismic` works better. To center the colormap in zero, the minimum
and maximum values to plot are set to -4 and 4 respectively.
Also, only genes with a log fold change of 3 or more are shown.

.. plot::
    :context: close-figs

    sc.pl.rank_genes_groups_dotplot(
        adata,
        n_genes=4,
        values_to_plot="logfoldchanges", cmap='bwr',
        vmin=-4,
        vmax=4,
        min_logfoldchange=3,
        colorbar_title='log fold change'
    )

Also, the last genes can be plotted. This can be useful to identify genes
that are lowly expressed in a group. For this `n_genes=-4` is used

.. plot::
    :context: close-figs

    sc.pl.rank_genes_groups_dotplot(
        adata,
        n_genes=-4,
        values_to_plot="logfoldchanges",
        cmap='bwr',
        vmin=-4,
        vmax=4,
        min_logfoldchange=3,
        colorbar_title='log fold change',
    )

A list specific genes can be given to check their log fold change. If a
dictionary, the dictionary keys will be added as labels in the plot.

.. plot::
    :context: close-figs

    var_names = {'T-cell': ['CD3D', 'CD3E', 'IL32'],
                  'B-cell': ['CD79A', 'CD79B', 'MS4A1'],
                  'myeloid': ['CST3', 'LYZ'] }
    sc.pl.rank_genes_groups_dotplot(
        adata,
        var_names=var_names,
        values_to_plot="logfoldchanges",
        cmap='bwr',
        vmin=-4,
        vmax=4,
        min_logfoldchange=3,
        colorbar_title='log fold change',
    )

.. currentmodule:: scanpy

See also
--------
tl.rank_genes_groups

sc.tl.rank_genes_groups:
Rank genes for characterizing groups.

Expects logarithmized data.

Parameters
----------
adata
    Annotated data matrix.
groupby
    The key of the observations grouping to consider.
mask_var
    Select subset of genes to use in statistical tests.
use_raw
    Use `raw` attribute of `adata` if present.
layer
    Key from `adata.layers` whose value will be used to perform tests on.
groups
    Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison
    shall be restricted, or `'all'` (default), for all groups. Note that if
    `reference='rest'` all groups will still be used as the reference, not
    just those specified in `groups`.
reference
    If `'rest'`, compare each group to the union of the rest of the group.
    If a group identifier, compare with respect to this group.
n_genes
    The number of genes that appear in the returned tables.
    Defaults to all genes.
method
    The default method is `'t-test'`,
    `'t-test_overestim_var'` overestimates variance of each group,
    `'wilcoxon'` uses Wilcoxon rank-sum,
    `'logreg'` uses logistic regression. See :cite:t:`Ntranos2019`,
    `here <https://github.com/scverse/scanpy/issues/95>`__ and `here
    <https://www.nxn.se/valent/2018/3/5/actionable-scrna-seq-clusters>`__,
    for why this is meaningful.
corr_method
    p-value correction method.
    Used only for `'t-test'`, `'t-test_overestim_var'`, and `'wilcoxon'`.
tie_correct
    Use tie correction for `'wilcoxon'` scores.
    Used only for `'wilcoxon'`.
rankby_abs
    Rank genes by the absolute value of the score, not by the
    score. The returned scores are never the absolute values.
pts
    Compute the fraction of cells expressing the genes.
key_added
    The key in `adata.uns` information is saved to.
copy
    Whether to copy `adata` or modify it inplace.
kwds
    Are passed to test methods. Currently this affects only parameters that
    are passed to :class:`sklearn.linear_model.LogisticRegression`.
    For instance, you can pass `penalty='l1'` to try to come up with a
    minimal set of genes that are good predictors (sparse solution meaning
    few non-zero fitted coefficients).

Returns
-------
Returns `None` if `copy=False`, else returns an `AnnData` object. Sets the following fields:

`adata.uns['rank_genes_groups' | key_added]['names']` : structured :class:`numpy.ndarray` (dtype `object`)
    Structured array to be indexed by group id storing the gene
    names. Ordered according to scores.
`adata.uns['rank_genes_groups' | key_added]['scores']` : structured :class:`numpy.ndarray` (dtype `object`)
    Structured array to be indexed by group id storing the z-score
    underlying the computation of a p-value for each gene for each
    group. Ordered according to scores.
`adata.uns['rank_genes_groups' | key_added]['logfoldchanges']` : structured :class:`numpy.ndarray` (dtype `object`)
    Structured array to be indexed by group id storing the log2
    fold change for each gene for each group. Ordered according to
    scores. Only provided if method is 't-test' like.
    Note: this is an approximation calculated from mean-log values.
`adata.uns['rank_genes_groups' | key_added]['pvals']` : structured :class:`numpy.ndarray` (dtype `float`)
    p-values.
`adata.uns['rank_genes_groups' | key_added]['pvals_adj']` : structured :class:`numpy.ndarray` (dtype `float`)
    Corrected p-values.
`adata.uns['rank_genes_groups' | key_added]['pts']` : :class:`pandas.DataFrame` (dtype `float`)
    Fraction of cells expressing the genes for each group.
`adata.uns['rank_genes_groups' | key_added]['pts_rest']` : :class:`pandas.DataFrame` (dtype `float`)
    Only if `reference` is set to `'rest'`.
    Fraction of cells from the union of the rest of each group
    expressing the genes.

Notes
-----
There are slight inconsistencies depending on whether sparse
or dense data are passed. See `here <https://github.com/scverse/scanpy/blob/main/scanpy/tests/test_rank_genes_groups.py>`__.

Examples
--------
>>> import scanpy as sc
>>> adata = sc.datasets.pbmc68k_reduced()
>>> sc.tl.rank_genes_groups(adata, 'bulk_labels', method='wilcoxon')
>>> # to visualize the results
>>> sc.pl.rank_genes_groups(adata)

================================================================================

CODE CELL 7 (Cell Index 19)
Documentation Length: 1560 characters
Status: SUCCESS
------------------------------------------------------------

SOURCE CODE:
```python
import scanpy as sc
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import mannwhitneyu

# Define the NF‐κB gene signature
nfkb_genes = ['NFKB1', 'RELA', 'NFKBIA', 'RELB', 'NFKB2']

# Check if the NF‐κB genes exist in the T cell subset; warn if any are missing
missing_genes = [gene for gene in nfkb_genes if gene not in adata_t.var_names]
if missing_genes:
    print(f'Warning: The following NF-κB genes are missing from the dataset: {missing_genes}')

# Compute the normalized NF‐κB pathway score for T cells
# Note: sc.tl.score_genes automatically normalizes by comparing to a set of reference genes
sc.tl.score_genes(adata_t, gene_list=nfkb_genes, score_name='NFkB_score')

# Separate the NF‐κB scores by TNFRSF1A expression group (assumes adata_t.obs['TNFRSF1A_grp'] is precomputed based on median expression)
high_scores = adata_t.obs.loc[adata_t.obs['TNFRSF1A_grp'] == 'High', 'NFkB_score']
low_scores  = adata_t.obs.loc[adata_t.obs['TNFRSF1A_grp'] == 'Low', 'NFkB_score']

# Perform Mann–Whitney U test if both groups have sufficient cell numbers
if high_scores.shape[0] >= 3 and low_scores.shape[0] >= 3:
    stat, p_val = mannwhitneyu(high_scores, low_scores, alternative='two-sided')
    print(f"Mann-Whitney U test statistic: {stat:.2f}, p-value: {p_val:.3e}")
else:
    print('Not enough cells in one of the groups to perform Mann-Whitney U test.')

# Visualization: Boxplot of NF‐κB scores stratified by TNFRSF1A group
plt.figure(figsize=(6,4))
ax = sns.boxplot(x='TNFRSF1A_grp', y='NFkB_score', data=adata_t.obs, palette='Set3')

# Customize the y-axis limits to focus on the central data range
y_min, y_max = ax.get_ylim()
ax.set_ylim([y_min - 0.1 * abs(y_min), y_max + 0.1 * abs(y_max)])

plt.title('NF-κB Pathway Score by TNFRSF1A Expression Group')
plt.xlabel('TNFRSF1A Group')
plt.ylabel('NF-κB Score')

# Annotate the plot with the p-value if available
if 'p_val' in locals():
    plt.annotate(f'p = {p_val:.2e}', xy=(0.5, 0.95), xycoords='axes fraction', ha='center', fontsize=12, color='red')

plt.tight_layout()
plt.show()
```

DOCUMENTATION:
sc.tl.score_genes:
Score a set of genes :cite:p:`Satija2015`.

The score is the average expression of a set of genes subtracted with the
average expression of a reference set of genes. The reference set is
randomly sampled from the `gene_pool` for each binned expression value.

This reproduces the approach in Seurat :cite:p:`Satija2015` and has been implemented
for Scanpy by Davide Cittaro.

Parameters
----------
adata
    The annotated data matrix.
gene_list
    The list of gene names used for score calculation.
ctrl_as_ref
    Allow the algorithm to use the control genes as reference.
    Will be changed to `False` in scanpy 2.0.
ctrl_size
    Number of reference genes to be sampled from each bin. If `len(gene_list)` is not too
    low, you can set `ctrl_size=len(gene_list)`.
gene_pool
    Genes for sampling the reference set. Default is all genes.
n_bins
    Number of expression level bins for sampling.
score_name
    Name of the field to be added in `.obs`.
random_state
    The random seed for sampling.
copy
    Copy `adata` or modify it inplace.
use_raw
    Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.

    .. versionchanged:: 1.4.5
       Default value changed from `False` to `None`.

Returns
-------
Returns `None` if `copy=False`, else returns an `AnnData` object. Sets the following field:

`adata.obs[score_name]` : :class:`numpy.ndarray` (dtype `float`)
    Scores of each cell.

Examples
--------
See this `notebook <https://github.com/scverse/scanpy_usage/tree/master/180209_cell_cycle>`__.

================================================================================

